#
# =================================================================
# =================================================================

import copy
import json
from nova.openstack.common import log as logging
from oslo.config import cfg

from powervc_nova import _
from powervc_nova.network.powerkvm import agent
from powervc_nova.network.powerkvm.agent import micro_op_builder as mob,\
    commandlet
from powervc_nova.network.powerkvm.agent import service_network_restart \
    as snr
from powervc_nova.network.powerkvm.agent.common import exception


LOG = logging.getLogger(__name__)
CONF = cfg.CONF


class OVSOperationRunner():
    """
    Takes in a current DOM and a desired DOM, and determines the set of micro
    operations that need to be executed to make the current DOM match the
    desired DOM.
    """

    def __init__(self, current_dom, desired_dom, force_flag, rollback):
        """
        :param current_dom: A HostOVSNetworkConfig object that represents the
                            current state of the host.
        :param desired_dom: A HostOVSNetworkConfig object that represents the
                            desired state of the host.
        :param force_flag: If true, run execute and ignore warnings (errors
                            are never ignored).
        :param rollback: Whether the operation should be rolled back before
                         completion, often to test the rollback mechanism.
        """
        self.current_dom = current_dom
        self.desired_dom = desired_dom
        self.force_flag = force_flag
        self.rollback = rollback

    def update_host_ovs(self, context):
        """update host ovs data on current host"""
        LOG.info(_('Updating Open vSwitch host data...'))
        LOG.debug("Current DOM: %s" % self.current_dom.to_dict())
        LOG.debug("Requested DOM: %s" % self.desired_dom.to_dict())

        builder = mob.MicroOperationBuilder(context,
                                            self.current_dom,
                                            self.desired_dom,
                                            self.rollback)

        mo_list = builder.get_micro_ops_for_update()

        # run validation
        return self._run_micro_op_list(mo_list)

    def _run_micro_op_list(self, mo_list):
        """
        Run validation and, if force_flag is true or no warnings, run
        execute.  Any errors encountered during execute will result in
        an undo call, in reverse order, on all previously executed
        micro ops.
        :param mo_list: A list of all micro ops needed to run the
                        desired operation.  This list should be
                        generated by the micro ops builder.
        :returns: A dictionary containing all warnings and errors
                    encountered during the running of the micro ops.

        """
        current_dom = copy.deepcopy(self.current_dom)
        warning_list = []
        return_dict = {}
        ifcfgs = ''
        ovsvsctl_show = {}

        # always run validation, even if force flag is
        # set to True to make sure there are no errors
        # encountered.
        ops_ran_list = []
        for micro_op in mo_list:
            try:
                ops_ran_list.append(micro_op.__class__.__name__)
                LOG.debug("running micro op %s with DOM %s" %
                          (micro_op.__class__,
                           current_dom))
                current_dom, curr_warning_list = \
                    micro_op.validate(current_dom)
                warning_list.extend(curr_warning_list)
                for warning in curr_warning_list:
                    LOG.warn(_('Warning "%(warn_name)s" occurred during '
                               'validation of operation %(oper)s: %(warn)s') %
                             {'warn_name': warning.name,
                              'oper': micro_op.__class__.__name__,
                              'warn': warning})
            except Exception as exc:
                LOG.exception(exc)
                LOG.error(_("List of operations run: %s" % ops_ran_list))
                return_dict[agent.ERRORS_KEY] = [{'message': '%s' % exc}]
                break

        # if the force flag is set we can ignore warnings but
        # we cannot avoid errors, so check to be sure there
        # were no errors
        ops_ran_list = []

        if((self.force_flag or len(warning_list) == 0)
           and agent.ERRORS_KEY not in return_dict):

            # in case of error, last_index is used to determine
            # where to start undo from
            last_index = -1

            # execute micro op list
            for i in range(0, len(mo_list)):
                try:
                    ops_ran_list.append(mo_list[i].__class__.__name__)
                    mo_list[i].execute()
                except Exception as exc:
                    LOG.exception(exc)
                    LOG.error(_("List of operations run: %s" % ops_ran_list))
                    return_dict[agent.ERRORS_KEY] = [{'message': "%s" % exc}]
                    last_index = i
                    break

            # do we need to undo because of error?
            if last_index != -1:
                LOG.error(_("Error during operation execution, undoing "
                            "operations..."))

                # Get the current state of the ifcfg files and ovs to log later
                try:
                    ifcfgs = commandlet.CommandExecutor.\
                        get_all_ifcfg_files_for_logging()
                    ovsvsctl_show = \
                        commandlet.CommandExecutor.send_vsctl_command()
                except Exception as e:
                    LOG.exception(e)

                undo_list = []
                # yes, undo needed; undo in reverse order
                reversed_list = self._reorder_ops_for_undo(mo_list,
                                                           last_index)
                for op in reversed_list:
                    try:
                        op.undo()
                        undo_list.append(op.__class__.__name__)
                    except Exception as exc:
                        # if we hit an error during undo, we will
                        # add the error to the error list and continue
                        # to attempt to undo the remaining micro ops
                        LOG.exception(exc)
                        return_dict[agent.ERRORS_KEY].append(
                            {'message': '%s' % exc})

                LOG.error(_("Undone operations: %s" % undo_list))

        # we are not doing an execution, so return the warnings
        else:
            # add warnings to return list
            if len(warning_list) > 0:
                return_dict[agent.WARNINGS_KEY] = []
                for warning in warning_list:
                    return_dict[agent.WARNINGS_KEY].append(
                        {'message': '%s' % warning})

        # Errors/warnings occurred.  Log initial dom, request dom, the dom as
        # it was when the error occurred, operations run, ifcfg files, and
        # ovs-vsctl show output
        if return_dict is not {}:
            debug_info_list = []
            debug_info_list.append(_('Initial Object Model is:'))
            debug_info_list.append(json.dumps(self.current_dom.to_dict(),
                                              sort_keys=True, indent=4))
            debug_info_list.append(_('Requested Object Model is:'))
            debug_info_list.append(json.dumps(self.desired_dom.to_dict(),
                                              sort_keys=True, indent=4))
            debug_info_list.append(_('Current Object Model is:'))
            debug_info_list.append(json.dumps(current_dom.to_dict(),
                                              sort_keys=True, indent=4))
            debug_info_list.append(_("List of operations returned by builder: "
                                     "%s" % [mo_list[i].__class__.__name__
                                             for i in range(0, len(mo_list))]))
            if ifcfgs:
                # These are only logged on errors, not on warnings
                debug_info_list.append(_("Contents of ifcfg files: %s" %
                                         ifcfgs))
                debug_info_list.append(_("ovs-vsctl show: "))
                debug_info_list.append(json.dumps(ovsvsctl_show,
                                                  sort_keys=True,
                                                  indent=4))

            if agent.ERRORS_KEY in return_dict:
                for message in debug_info_list:
                    LOG.error(message)
            else:
                for message in debug_info_list:
                    LOG.warn(message)

        return return_dict

    def _reorder_ops_for_undo(self, micro_op_list, last_index):
        new_list = [micro_op_list[i] for i in range(0, last_index + 1)]
        new_list.reverse()
        for op in new_list:
            if isinstance(op, snr.ServiceNetworkRestart):
                LOG.debug("Moving network restart op to "
                          "the end of the list.")
                new_list.remove(op)
                new_list.append(op)
                break

        return new_list
